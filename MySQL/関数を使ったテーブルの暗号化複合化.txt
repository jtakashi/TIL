mysqlのテーブルのカラムを暗号化＆複合化してみる。

適当なデータベースを作ってその中で
以下のテーブルを作成

CREATE TABLE USER  (
  id int(10) NOT NULL AUTO_INCREMENT,
  name varchar(30) NOT NULL,
  PRIMARY KEY (id)
);

データを暗号化しながら入れる
insert into user (name)
values(HEX(AES_ENCRYPT('taro', 'PWD')));

が、エラーが出る。
ERROR 1406 (22001): Data too long for column 'name' at row 1
意味は（テーブルの設定より文字列が長い）

ここは飛ばしてもいい
　　｜エラーをコピペして以下の対応が見つかる。
　　｜(ただし、これは必要なかった。その理由が勉強になったので
　　｜記録として残しておく。「テーブルの設定を変更」まで飛ばしていい）
　　｜my.iniへ以下を追記
　　｜[mysqld]
　　｜sql_mode=''
　　｜
　　｜これやってはだめだった
　　｜128ビット＝32文字の暗号になってるのでテーブルの設定を変更してあげないといけなかった。
　　｜
　　｜my.iniの変更を取り消し;

テーブルの設定を変更
ALTER TABLE user modify name VARCHAR(32);　//デフォルトでは暗号は128bit=32バイトで生成されるため
SHOW COLUMNS FROM user; で確認

データを入れなおす
insert into user (name)
values(HEX(AES_ENCRYPT('taro', 'PWD')));   

暗号化されているか確認
select * from user;
例
+----+----------------------------------+
| id | name                             |
+----+----------------------------------+
|  1 | 45BB95BF340E7B7A78D1CAFFC7ADC72B |
+----+----------------------------------+

本当のパスワードを複合と同時にselect

select
  convert(
    AES_DECRYPT(UNHEX(name), 'PWD')
    USING utf8
  )
from
  user;
出力例
+-----------------------------------------------------------------+
| convert(
    AES_DECRYPT(UNHEX(name), 'PWD')
    USING utf8								
  ) |								    // この部分は戻り値じゃないっぽいので変数に入れる										
+-----------------------------------------------------------------+ //ときに入ってきちゃうの？　みたいな心配は不要。
| taro                                                            |
+-----------------------------------------------------------------+

//仕組みとしてはPWDという文字列をカギにして暗号化と複合化をしているとおもわれる
//この暗号化カギは現場だとどのように管理されているのかはいまいちわからなかったが
//責任者がツールを使って外部で管理し、中身が見えないまま変数に代入するみたいなことをするんじゃないかと思った。
